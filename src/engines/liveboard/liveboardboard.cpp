/*
*   This file is part of QRail.
*
*   QRail is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   QRail is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with QRail.  If not, see <http://www.gnu.org/licenses/>.
*/
#include "engines/liveboard/liveboardboard.h"
using namespace QRail;

QRail::LiveboardEngine::Board::Board(QObject *parent) : QObject(parent)
{

}

QRail::LiveboardEngine::Board::Board(const QList<QRail::VehicleEngine::Vehicle *> &entries,
                                     StationEngine::Station *station, const QDateTime &from, const QDateTime &until,
                                     QObject *parent): QObject(parent)
{
    // Use private members to avoid signal firing on construction
    m_entries = entries;
    m_station = station;
    m_from = from;
    m_until = until;
}

void QRail::LiveboardEngine::Board::addEntry(QRail::VehicleEngine::Vehicle *entry)
{
    // QRail::VehicleEngine::Vehicle is generated by a factory, the factory manages the memory usage itself with a cache.
    QList<QRail::VehicleEngine::Vehicle *> entries = this->entries();
    entries.append(entry);
    /*
     * Sort the entries on arrival or departure time (due concurrent access).
     *
     * We can use the .first() method to retrieve the stop since the liveboard
     * only adds one stop to the intermediaryStops list.
     * If the user wants to retrieve the full vehicle he/she can use the
     * VehicleEngine API to retrieve the full intermediaryStops list.
     */
    if (this->mode() == QRail::LiveboardEngine::Board::Mode::ARRIVALS) {
        // Use arrival time to sort
        std::sort(entries.begin(), entries.end(), [](const QRail::VehicleEngine::Vehicle * a,
        const QRail::VehicleEngine::Vehicle * b) -> bool {
            QDateTime timeA = a->intermediaryStops().first()->arrivalTime();
            QDateTime timeB = b->intermediaryStops().first()->arrivalTime();
            return timeA < timeB;
        });
    } else if (this->mode() == QRail::LiveboardEngine::Board::Mode::DEPARTURES) {
        // Use departure time to sort
        std::sort(entries.begin(), entries.end(), [](const QRail::VehicleEngine::Vehicle * a,
        const QRail::VehicleEngine::Vehicle * b) -> bool {
            QDateTime timeA = a->intermediaryStops().first()->departureTime();
            QDateTime timeB = b->intermediaryStops().first()->departureTime();
            return timeA < timeB;
        });
    } else {
        qCritical() << "Sorting Liveboard::Board failed! Unknown Liveboard::Board::Mode";
    }
    this->setEntries(entries);
}

QUrl QRail::LiveboardEngine::Board::hydraNext() const
{
    return m_hydraNext;
}

void QRail::LiveboardEngine::Board::setHydraNext(const QUrl &hydraNext)
{
    // New hydraNext URI is further in time?
    if (hydraNext.hasQuery() && this->hydraNext().isValid()) {
        QUrlQuery queryNewHydraNext = QUrlQuery(hydraNext.query());
        QUrlQuery queryOldHydraNext = QUrlQuery(this->hydraNext().query());
        QDateTime timeNewHydraNext = QDateTime::fromString(
                                         queryNewHydraNext.queryItemValue("departureTime"), Qt::ISODate);
        QDateTime timeOldHydraNext = QDateTime::fromString(
                                         queryOldHydraNext.queryItemValue("departureTime"), Qt::ISODate);

        qDebug() << "HYDRA NEXT=" << hydraNext << timeNewHydraNext << "|" << this->hydraNext() <<
                 timeOldHydraNext;
        // Only accept URI that's later in time
        if (timeNewHydraNext > timeOldHydraNext) {
            m_hydraNext = hydraNext;
            qDebug() << "Hydra next NEW:" << m_hydraNext;
            emit this->hydraNextChanged();
        }
    }
    // Current hydraNext is still empty, setting it to the received hydraNext
    else {
        qDebug() << "Empty hydraNext";
        m_hydraNext = hydraNext;
        emit this->hydraNextChanged();
    }
}

QUrl QRail::LiveboardEngine::Board::hydraPrevious() const
{
    return m_hydraPrevious;
}

void QRail::LiveboardEngine::Board::setHydraPrevious(const QUrl &hydraPrevious)
{
    // New hydraPrevious URI is earlier in time?
    if (hydraPrevious.hasQuery() && this->hydraPrevious().hasQuery()) {
        QUrlQuery queryNewHydraPrevious = QUrlQuery(hydraPrevious.query());
        QUrlQuery queryOldHydraPrevious = QUrlQuery(this->hydraPrevious().query());
        QDateTime timeNewHydraPrevious = QDateTime::fromString(
                                             queryNewHydraPrevious.queryItemValue("departureTime"), Qt::ISODate);
        QDateTime timeOldHydraPrevious = QDateTime::fromString(
                                             queryOldHydraPrevious.queryItemValue("departureTime"), Qt::ISODate);
        qDebug() << "HYDRA PREVIOUS=" << hydraPrevious << timeNewHydraPrevious << "|" <<
                 this->hydraPrevious() <<
                 timeOldHydraPrevious;
        // Only accept URI that's earlier in time
        if (timeNewHydraPrevious < timeOldHydraPrevious) {
            m_hydraPrevious = hydraPrevious;
            qDebug() << "Hydra previous NEW:" << m_hydraPrevious;
            emit this->hydraPreviousChanged();
        }
    }
    // Current hydraPrevious is still empty, setting it to the received hydraPrevious
    else {
        qDebug() << "Empty hydraPrevious";
        m_hydraPrevious = hydraPrevious;
        emit this->hydraPreviousChanged();
    }
}

// Getters & Setters
StationEngine::Station *QRail::LiveboardEngine::Board::station() const
{
    return m_station;
}

void QRail::LiveboardEngine::Board::setStation(StationEngine::Station *station)
{
    m_station = station;
    emit this->stationChanged();
}

QDateTime QRail::LiveboardEngine::Board::until() const
{
    return m_until;
}

void QRail::LiveboardEngine::Board::setUntil(const QDateTime &until)
{
    if(m_until.isValid() && m_until < until) {
        m_until = until;
    }
    else if(!m_until.isValid()) {
        m_until = until;
    }
    emit this->untilChanged();
}

QRail::LiveboardEngine::Board::Mode QRail::LiveboardEngine::Board::mode() const
{
    return m_mode;
}

void QRail::LiveboardEngine::Board::setMode(const QRail::LiveboardEngine::Board::Mode &mode)
{
    m_mode = mode;
    emit this->modeChanged();
}

QDateTime QRail::LiveboardEngine::Board::from() const
{
    return m_from;
}

void QRail::LiveboardEngine::Board::setFrom(const QDateTime &from)
{
    if(m_from.isValid() && m_from > from) {
        m_from = from;
    }
    else if(!m_from.isValid()) {
        m_from = from;
    }
    emit this->fromChanged();
}

QList<QRail::VehicleEngine::Vehicle *> QRail::LiveboardEngine::Board::entries() const
{
    return m_entries;
}

void QRail::LiveboardEngine::Board::setEntries(const QList<QRail::VehicleEngine::Vehicle *>
                                               &entries)
{
    m_entries = entries;
    emit this->entriesChanged();
}
